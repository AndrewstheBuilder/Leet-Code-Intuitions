### [Problem Valid Palindrome III]()
```python
    def isValidPalindrome(self, s: str, k: int) -> bool:
        i = 0
        j = len(s)-1
        # memo = [[-1]*len(s)]*len(s) # this creates a shallow copy of each list
        memo = [[-1 for _ in range(len(s))] for _ in range(len(s))]
        def recurse(i,j):
            if i==j or i>j:
                return 0 # done processing string

            if memo[i][j] != -1:
                return memo[i][j]

            if s[i] != s[j]:
                # characters do not match
                # try both paths
                memo[i][j]=1+min(recurse(i+1,j), recurse(i,j-1))
                return memo[i][j]
            # characters match move on
            memo[i][j]=recurse(i+1, j-1)
            return memo[i][j]
        
        return recurse(i,j)<=k
```
- Time Complexity: O(n^2) we are going to find each pair of i,j when there is a character mismatch. O(n^2)
- Space Complexity: the function stack will be O(n), but the space complexity will be dominated by the memo data structure which is O(n^2)

### [Search in Rotated Sorted Array]()
- Use binary search.
- Rotational correction see if the left halve is in sorted order then compare the range to see if target will exist inside of it. (One half of the array will always be sorted at least.) if its not in the range of sorted left array its in the right array move binary search there.
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if nums==None:
            return -1
        
        left,right = 0, len(nums)-1
        while left<right:
            mid=(left+right)//2
            if nums[mid]==target:
                return mid
            
            # if the left subarray [left:mid] is sorted, check if the 
            # target falls in this range. If it does, search the left
            # subarray. Otherwise, search the right
            elif nums[left]<=nums[mid]:
                if nums[left] <=target <nums[mid]:
                    right=mid-1
                else:
                    left=mid+1
            # if the right subarray [mid:right] is sorted, check if the 
            # target falls in this range, If it does, search the right subarray
            # Otherwise search the left.
            else:
                if nums[mid] < target <=nums[right]:
                    left = mid+1
                else:
                    right=mid-1
        # if the target is found in the array , return its index. Otherwise,
        # return -1
        return left if nums[left]==target else -1
```
