### [Problem Valid Palindrome III]()
```python
    def isValidPalindrome(self, s: str, k: int) -> bool:
        i = 0
        j = len(s)-1
        # memo = [[-1]*len(s)]*len(s) # this creates a shallow copy of each list
        memo = [[-1 for _ in range(len(s))] for _ in range(len(s))]
        def recurse(i,j):
            if i==j or i>j:
                return 0 # done processing string

            if memo[i][j] != -1:
                return memo[i][j]

            if s[i] != s[j]:
                # characters do not match
                # try both paths
                memo[i][j]=1+min(recurse(i+1,j), recurse(i,j-1))
                return memo[i][j]
            # characters match move on
            memo[i][j]=recurse(i+1, j-1)
            return memo[i][j]
        
        return recurse(i,j)<=k
```
- Time Complexity: O(n^2) we are going to find each pair of i,j when there is a character mismatch. O(n^2)
- Space Complexity: the function stack will be O(n), but the space complexity will be dominated by the memo data structure which is O(n^2)

### [Search in Rotated Sorted Array]()
- Use binary search.
- Rotational correction see if the left halve is in sorted order then compare the range to see if target will exist inside of it. (One half of the array will always be sorted at least.) if its not in the range of sorted left array its in the right array move binary search there.
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if nums==None:
            return -1
        
        left,right = 0, len(nums)-1
        while left<right:
            mid=(left+right)//2
            if nums[mid]==target:
                return mid
            
            # if the left subarray [left:mid] is sorted, check if the 
            # target falls in this range. If it does, search the left
            # subarray. Otherwise, search the right
            elif nums[left]<=nums[mid]:
                if nums[left] <=target <nums[mid]:
                    right=mid-1
                else:
                    left=mid+1
            # if the right subarray [mid:right] is sorted, check if the 
            # target falls in this range, If it does, search the right subarray
            # Otherwise search the left.
            else:
                if nums[mid] < target <=nums[right]:
                    left = mid+1
                else:
                    right=mid-1
        # if the target is found in the array , return its index. Otherwise,
        # return -1
        return left if nums[left]==target else -1
```
### [Word Break]()
- If anything is ambiguous in the requirements clarify it.
```
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.
```
- Does this mean all the segmented words in s has to be in dict? Yes
- And once a word is chosen from s we cannot reuse its letters to form another word in d.
```
Example:
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
```

``` python
def wordBreak(s:str, dict_s:List[str]) -> bool:
    # if s can be broken down into words that are in dict. Can reuse words in dict
    queue=deque([0])
    seen=set()
    n = len(s)
    words = set(dict_s)
    while queue:
        start = queue.popleft()
        if start==n:
            # reached end of string
            # with positive affirmation of being able to go edge to edge in s
            return True
        for end in range(start,n):
            if end in seen:
                continue
            if s[start:end+1] in words:
                queue.append(end+1)
                seen.add(end)
    return False
# Time Complexity: O(n^3 + m*k)
# Space Complexity: O(n + m*k) -> queue and seen
# What is BFS doing here ?
    # BFS is moving from one substring boundary to the next valid boundary
    # the BFS "nodes" represent indices in the original string, and the "edges" represent valid dictionary words bridging those indices.
    # Comprehensive coverage of valid segmentations: While you won't re-check identical edges from the same starting point, the BFS process will still explore every unique valid segmentation of the string. Thus, if there's a valid path from start to end, BFS will find it.
        # we are not exploring the same edge twice.
        # we still explore every valid segmentation
        # 'apple' dict='app','apple','le'. We will explore up to 'apple' but not a new edge 'le'
```
- Do not put mutable types as default arguments in functions
```python
def func(dict_a={})

# dictionaries are mutable. this default instance will be shared across all function calls to func()
```
### [Basic Calculator III]()
```python
	class Solution:
	    def tokenize(self,expression: str) -> List[str]:
	        # Regular expression to match numbers (integer or float) and operators
	        token_pattern = r'(\d+(?:\.\d+)?|[\+\-\*/\^\(\)])'
	        tokens = re.findall(token_pattern, expression)
	        return tokens
	        
	    def infix_to_postfix(self,tokens: List[str]) -> List[str]:
	        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}
	        output = []
	        operator_stack = []
	        for token in tokens:
	            if token.isnumeric():  # Numbers
	                output.append(token)
	            elif token in precedence:  # Operators
	                while (operator_stack and operator_stack[-1] in precedence and
	                    precedence[token] <= precedence[operator_stack[-1]]):
	                    output.append(operator_stack.pop())
	                operator_stack.append(token)
	            elif token == '(':  # Open parenthesis
	                operator_stack.append(token)
	            elif token == ')':  # Close parenthesis
	                while operator_stack and operator_stack[-1] != '(':
	                    output.append(operator_stack.pop())
	                operator_stack.pop()  # Remove '('
	        # Pop any remaining operators
	        while operator_stack:
	            output.append(operator_stack.pop())
	        return output
	
	    def eval_postfix(self,postfix: List[str]) -> int:
	        stack = []
	        for token in postfix:
	            if token.isnumeric():  # Numbers
	                stack.append(int(token))  # Use float to handle decimals
	            else:  # Operators
	                b = stack.pop()
	                a = stack.pop()
	                if token == '+':
	                    stack.append(a + b)
	                elif token == '-':
	                    stack.append(a - b)
	                elif token == '*':
	                    stack.append(a * b)
	                elif token == '/':
	                    stack.append(int(a / b))
	        return int(stack[0])  # Convert to int if the final result is an integer
	        
	    def calculate(self, s: str) -> int:
	        tokens = self.tokenize(s)
	        postfix = self.infix_to_postfix(tokens)
	        ans = self.eval_postfix(postfix)
	        return ans
```
- Took the right approach breaking it down into util functions. I needed a large example to get the idea of a post fix expression.
- ``(0-3)/4`` -> ``postfix: [0,3-,4,/]
- To truncate do `int(a/b)` instead of `a//b` the flooring operation will go towards the lowest int. In negative numbers it goes away from 0. And we want to truncate towards 0.
- I assumed the tokenize function would be provided to me.
### From Coding Patterns Book [Shortest Transformation Sequence]()
- We are given a word and told transformations inside dictionary will lead it to a end word. 
	- Word='abc', endword='def', dictionary=['abc', 'dbc', 'dec','def']
		- 'abc' -> 'dbc' -> 'dec' -> 'def', output=4
	- We are only allowed to do one transformation at a time
	- This is a graph search problem we can change at most one character at a time and check if its in dictionary. 
	- BFS should be used for all shortest path problems on unweighted graphs since it does a level by level traversal and is guaranteed to reach the destination in the shortest time
- Remember list slicing is guaranteed to be null safe.
```python
# Instructions:
# Shortest Transformation Sequence
# Given two words, start and end, and a dictionary containing an array of words, return the length
# of the shortest transformation sequence to transform start to end. A transformation sequence is
# a sequence of words in which:
    # Each word differs from the preceding word by exactly one letter
    # Each word in the sequence exists in the dictionary
# If no such transformation sequence exists, return 0
# start and end are guaranteed to have the same number of letters
# all of these have lower case english letters

# start='ab' end='de' dictionary=['ab', 'ae', 'de'], output=2
# queue=(
# seen=('ab','ae'
# 'ab' -> 'ae' -> 'de'
# output=2

def shortestTransformSeq(start:str,end:str,dictionary:List[str]) -> int:
    output=0
    queue=deque([start])
    seen=set([start])
    dictionary=set(dictionary)
    all_letters='abcdefghijklmnopqrstuvwxyz'

	# edge cases
    if start not in dictionary or end not in dictionary:
        return 0
    if start==end:
        return 1

    while queue:
        word=queue.popleft()
        if word==end:
            return output+1
        for i in range(len(word)):
            for l in all_letters:
                newWord = word[:i] + l + word[i+1:]
                if newWord in dictionary and newWord not in seen:
                    queue.append(newWord)
                    seen.add(newWord)
        output+=1
    return 0
```