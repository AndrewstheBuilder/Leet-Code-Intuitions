1. [Clone Graph](https://leetcode.com/problems/clone-graph/?envType=company&envId=facebook&favoriteSlug=facebook-thirty-days)
```python
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return node

        visited = {}
        def visit(node):
            if node.val in visited:
                return visited[node.val]
            n = Node(node.val)
            visited[node.val] = n
            n.neighbors = [visit(ni) for ni in node.neighbors]
            return n
        return visit(node)
```
- The structure of the input was implied. We were given test cases that did not match the structure of the input.
- The intuition here is to visit each node as we are going and find its neighbors as we visit by recursively calling visit on its neighbors.
    - We manage the edge case of the node being null by returning node right away
    - Then at the end we return the node. Which works for the first call we do and all subsequent call on its neighbors. We are recursively going into its neighbors.
    - We have a to store a visited data structure becauses its a graph with no directions so to say that node a is connected to node b we do [a,b],[b,a] a bidirectional connection means it has no specified direction
- Time Complexity: O(n) we process each node once
- Space Complexity: O(n) we store the function in the call stack for the amount of nodes in the graph. We return immediately if the node has been visited.
