1. [Clone Graph](https://leetcode.com/problems/clone-graph/?envType=company&envId=facebook&favoriteSlug=facebook-thirty-days)
```python
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return node

        visited = {}
        def visit(node):
            if node.val in visited:
                return visited[node.val]
            n = Node(node.val)
            visited[node.val] = n
            n.neighbors = [visit(ni) for ni in node.neighbors]
            return n
        return visit(node)
```
- The structure of the input was implied. We were given test cases that did not match the structure of the input.
- The intuition here is to visit each node as we are going and find its neighbors as we visit by recursively calling visit on its neighbors.
    - We manage the edge case of the node being null by returning node right away
    - Then at the end we return the node. Which works for the first call we do and all subsequent call on its neighbors. We are recursively going into its neighbors.
    - We have a to store a visited data structure becauses its a graph with no directions so to say that node a is connected to node b we do [a,b],[b,a] a bidirectional connection means it has no specified direction
- Time Complexity: O(n) we process each node once
- Space Complexity: O(n) we store the function in the call stack for the amount of nodes in the graph. We return immediately if the node has been visited.

2. [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/?envType=company&envId=facebook&favoriteSlug=facebook-thirty-days)
- Attempted solution. Did not work for all test cases notes below
```python

# Below attempted solution did not work but it was on the right track as the sliding window solution
# this took me a while to write. Possibly too much logic
# it was hard to explain everything while covering all scenarios so I have to simplify
    # I have to know the edge cases right away. I cannot think about it too long
def minWindow(self, s: str, t: str) -> str:
        h_t = {}
        total = 0
        for i in range(len(t)):
            total += 1
            h_t[t[i]] = h_t.get(t[i], 0) + 1
        
        left=0
        right=0
        shortest = []
        s_list=list(s)
        while left<len(s_list) and right<len(s_list) and left<=right:
            if total == 0:
                if((right-left+1)<len(shortest) or len(shortest) == 0):
                    shortest = s_list[left:right]
                # shrink window until we remove a t character from s_list
                # update shortest if condition still holds
                while left<=right and total==0:
                    if total==0:
                        shortest = s_list[left:right]
                    if s_list[left] in h_t:
                        h_t[s_list[left]] += 1
                        if(h_t[s_list[left]]>0):
                            total += 1
                    left += 1
            elif s_list[right] in h_t:
                h_t[s_list[right]] -= 1
                if h_t[s_list[right]] >= 0:
                    # subtract from total of the actual freq of chars in t
                    total -= 1
                right += 1
            else:
                right += 1 #expand the window
        if total == 0:
            if((right-left)<len(shortest) or len(shortest) == 0):
                shortest = s_list[left:right]
            # shrink window until we remove a t character from s_list
            # update shortest if condition still holds
            while left<right and total==0:
                if total==0 and (right-left)<len(shortest):
                    shortest = s_list[left:right]
                if s_list[left] in h_t:
                    h_t[s_list[left]] += 1
                    if(h_t[s_list[left]]>0):
                        total += 1
                left += 1
        return ''.join(shortest)
- Time Complexity: O(len(s))
- Space Complexity: O(len(s))
```
