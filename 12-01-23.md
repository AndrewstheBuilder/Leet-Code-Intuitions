1. [Clone Graph](https://leetcode.com/problems/clone-graph/?envType=company&envId=facebook&favoriteSlug=facebook-thirty-days)
```python
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return node

        visited = {}
        def visit(node):
            if node.val in visited:
                return visited[node.val]
            n = Node(node.val)
            visited[node.val] = n
            n.neighbors = [visit(ni) for ni in node.neighbors]
            return n
        return visit(node)
```
- The structure of the input was implied. We were given test cases that did not match the structure of the input.
- The intuition here is to visit each node as we are going and find its neighbors as we visit by recursively calling visit on its neighbors.
    - We manage the edge case of the node being null by returning node right away
    - Then at the end we return the node. Which works for the first call we do and all subsequent call on its neighbors. We are recursively going into its neighbors.
    - We have a to store a visited data structure becauses its a graph with no directions so to say that node a is connected to node b we do [a,b],[b,a] a bidirectional connection means it has no specified direction
- Time Complexity: O(n) we process each node once
- Space Complexity: O(n) we store the function in the call stack for the amount of nodes in the graph. We return immediately if the node has been visited.

2. [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/?envType=company&envId=facebook&favoriteSlug=facebook-thirty-days)
- Attempted solution. Did not work for all test cases notes below
```python

# Below attempted solution did not work but it was on the right track as the sliding window solution
# this took me a while to write. Possibly too much logic
# it was hard to explain everything while covering all scenarios so I have to simplify
    # I have to know the edge cases right away. I cannot think about it too long
def minWindow(self, s: str, t: str) -> str:
        h_t = {}
        total = 0
        for i in range(len(t)):
            total += 1
            h_t[t[i]] = h_t.get(t[i], 0) + 1
        
        left=0
        right=0
        shortest = []
        s_list=list(s)
        while left<len(s_list) and right<len(s_list) and left<=right:
            if total == 0:
                if((right-left+1)<len(shortest) or len(shortest) == 0):
                    shortest = s_list[left:right]
                # shrink window until we remove a t character from s_list
                # update shortest if condition still holds
                while left<=right and total==0:
                    if total==0:
                        shortest = s_list[left:right]
                    if s_list[left] in h_t:
                        h_t[s_list[left]] += 1
                        if(h_t[s_list[left]]>0):
                            total += 1
                    left += 1
            elif s_list[right] in h_t:
                h_t[s_list[right]] -= 1
                if h_t[s_list[right]] >= 0:
                    # subtract from total of the actual freq of chars in t
                    total -= 1
                right += 1
            else:
                right += 1 #expand the window
        if total == 0:
            if((right-left)<len(shortest) or len(shortest) == 0):
                shortest = s_list[left:right]
            # shrink window until we remove a t character from s_list
            # update shortest if condition still holds
            while left<right and total==0:
                if total==0 and (right-left)<len(shortest):
                    shortest = s_list[left:right]
                if s_list[left] in h_t:
                    h_t[s_list[left]] += 1
                    if(h_t[s_list[left]]>0):
                        total += 1
                left += 1
        return ''.join(shortest)
- Time Complexity: O(len(s))
- Space Complexity: O(len(s))
```
- Solution that works:
    - Keeping unique formed characters is genius.
    - the while shrinking loop is there without having a if statement. So is updating window_counts. It just makes for less lines of code. I do not think if I did have a extra check that it would affect logic
    - The order of updating then checking inside the dicts matters. r pointer gets updated at the end we process it at the beginning of the while loop to update window_counts and formed!
    - Its interesting they decided to shrink and contract in the same iteration. I guess we will not miss anything since we expand regardless of any logic and we shrink until the logic in while fails. If we shrunk then updated in next iteration it will bring back the same result.
``` python
 def minWindow(self, s: str, t: str) -> str:
        l,r=0,0
        dict_t = Counter(t)
        required = len(dict_t) # length of unique characters in t 
        formed = 0 # number of freq matching unique t chars encountered in s
        window_counts = {} # keep freq of chars of t encountered in s
        ans = float('inf'),-1,-1 # window length, left pointer, right pointer
        while r<len(s):
            window_counts[s[r]] = window_counts.get(s[r], 0) + 1
            if(s[r] in dict_t and window_counts[s[r]]==dict_t[s[r]]):
                # freq of unique char matched between s and t
                formed += 1
            # shrink window to find smallest possible substring if formed == required
            while l<=r and formed==required:
                if(r-l+1<ans[0]):
                    ans = ((r-l+1),l,r)
                window_counts[s[l]] -= 1
                if s[l] in dict_t and window_counts[s[l]] < dict_t[s[l]]:
                    formed -= 1 # unique chars freq is not the same between s and t
                l += 1
            # keep expanding once we are done contracting
            r += 1
        return "" if ans[0]==float('inf') else s[ans[1]:ans[2]+1]
```
