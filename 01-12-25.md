1. [Reorganize String
](https://leetcode.com/problems/reorganize-string/description/?envType=company&envId=amazon&favoriteSlug=amazon-thirty-days)
```python
class Solution:
    # func(chosen, remaining) -> func() until remaining is empty then return chosen
    # "aab"
    # c:"a", r:"ab" -> c:"ab", r:"a", -> c:"aba" return c
    # "baa"
    # 'ba' -> 'ab' -> 'aba'
    # recursive backtracking
    # def backtrack(chosen: List[str], remaining: List[str]) -> List[str]:
    #         # how will I add stuff to remaining and pop elements off of remaining?
    #         # if we return a chosen then it should ideally bubble up to the first recursive call and return that result.
    #         while remaining:
    #             if chosen:
                    
    #             else:
    #                 chosen.add(remaining[i])
    #                 remaining
    #             backtrack(chosen, remaining)
    #         return chosen

    # Alternate placing the most common letters
        # how would I gather up the most common letters?
        # gather counts : O(n)
        # sort counts: O(nlogn)
        # go down each count starting from the greatest to the least and append a char
    # "abddccceeee"    
    # max heap? -> get the priority, push into heap, pop from top of heap
        # how do we avoid adding an adjacent character after popping from heap?
            # keep popping from heap until we find a char that is not adjacent. This should not bring up the time complexity.
            # keep a prev entry from heap and after next iteration put prev back into heap
            # if only prev exists and there is nothing in heap then return ""

    # "ghhc"
    # priority:{'g':0, 'h':0, 'c':0}
    # mHeap=[], prev='c', char='c'
    # ans=['h','g', 'h', 'c']

    def reorganizeString(self, s: str) -> str:
        # gather priority of chars in s
        priority=defaultdict(int)
        for i in range(len(s)):
            priority[s[i]] += 1

        # create max heap
        mHeap = []
        for key,value in priority.items():
            heapq.heappush(mHeap, (-value, key))
        
        # form rearranged string
        ans=[]
        prev = ''
        while mHeap:
            value, char = heapq.heappop(mHeap)
            ans.append(char)
            priority[char]-=1
            if prev and priority[prev]!=0:
                heapq.heappush(mHeap, (-priority[prev], prev))
            prev = char
        if priority[prev] != 0:
            return ""
        return ''.join(ans)

        # Time Complexity: O(nlogk) n being length of string, k being height of binary tree
        # Space Complexity: O(n)
```
